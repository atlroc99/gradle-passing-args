plugins {
    id 'groovy'
    id 'java'
}

// apply plugin: "java" -> older / legacy way of doing it. use plugins {...} closure : https://stackoverflow.com/questions/32352816/what-the-difference-in-applying-gradle-plugin

group 'com.pass.args'
version 'V.1.0'

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.3.11'
    testCompile group: 'junit', name: 'junit', version: '4.12'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}

test {
    useJUnitPlatform()
}

// ext:  https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html

//executing the main class
task(runSimple, type: JavaExec) {
    main = 'com.pass.args.MainClass'
    classpath = sourceSets.main.runtimeClasspath
    args 'MrKakhi'
    println('project has property runLast: ' + project.hasProperty('runLast'))
    systemProperty 'simple.message', 'Hello there, '
    if (project.hasProperty('runLast')) {
        println 'project has property runLast'
    }
}
// this will run by default if we don't specify and gradle task name
defaultTasks 'runSimple'


// this task depends on the runSimple
task runLast {
    println('this shuold run at last')
}

/*ext.javaMainClass = 'com.pass.args.MainClass'
task runTaskWithJavaExec(type: JavaExec) {
//    group('execution')
    description('Running task with javaExec and pass args from teh commadn line')
    classpath = sourceSets.main.runtimeClasspath
    main = javaMainClass

    if (project.hasProperty('source') && project.hasProperty('destination')) {
        // soucePath = project.getProperty('source')
        // destination = project.getProperty('destination')
        args(project.getProperty('source'), project.getProperty('destination'))
    } else {
        args("")
    }
}*/


//setting system properties with the -D flag
//setting project properties with the -P flag


//usign tasks.register gradle V:6.8.3
tasks.register('intro') {
    doLast {
        println 'printing  intro...'
        String someStr = 'mY_nAmE'
        println "some string: $someStr"
        println "some string ${someStr.toUpperCase()}"
    }
}

tasks.register('outro') {
    dependsOn tasks.intro
    doLast {
        println 'this is OUTRO'
    }
}


//dynamically registering task
5.times { counter ->
    tasks.register("task$counter") {
        doLast {
            println "i am task number $counter"
        }
    }
}

// Manipulating existing tasks:
//------------------------------

//tasks.task0.dependsOn(tasks.task2, tasks.task3)
tasks.task0.dependsOn("task3", "task2")

tasks.register('firstTask') {
    doLast { Task task ->
        println "inside the first task print name: $task.name"
        println "message : ${message}"
    }
}

// Accessing tasks as project Properties
tasks.register('taskAsProjectProperty') {task ->
    doLast {
        println "\n\nthis task is accessed as project properties ${task.name}\n\n"
    }
}

taskAsProjectProperty.description('this is a description of task task as project properties')

boolean hasProp = project.hasProperty('taskAsProjectProperty')
println("*** has property ${} ${hasProp} *** ")

tasks.register('taskWithBoolean') {
    if (hasProp) {
        println "*** START ****"
        println ">>> task has property: ${hasProp}"
        Task tsk = project.properties.get('taskAsProjectProperty')
        String taskDescription = tsk.getDescription();
        if (taskDescription != null) {
            println taskDescription
        }
        println "**** END ****"
    }
}

//using ext -> Extra property
//A Task Object already come with several properties and method. we can add some extra properties on top of that.
// we use ext to add extra properties (variable / method)

ext {
    firstTask.message = "this message is a message"
    Task f = project.getProperties().get('firstTask')
    f.message = "this is a hello message added from ext"
}


//need to review Skipping task on chapter 2